  Neden Bir Design Pattern'e İhtiyaç Duyarız?
  Standartlaşma:
  - Tasarım desenleri, belirli bir problemi çözmek için kabul edilmiş bir çözüm
    yaklaşımı sunar.
    Bu, farklı geliştiriciler arasında iletişimi kolaylaştırır ve ortak bir dil oluşturur.
    Bu da yazılım projelerinin daha sürdürülebilir ve anlaşılabilir olmasını sağlar.

  Esneklik ve Değişiklik Kolaylığı:
  - Tasarım desenleri, kodun daha esnek ve değişikliklere karşı dirençli olmasını sağlayabilir.
    Bir tasarım deseni kullanarak oluşturulan bir yapı, daha sonra gelen gereksinim değişikliklerine
    daha kolay adapte olabilir.

  MVVM(Model - View - ViewModel) Nedir?
- Android uygulamaları geliştirmek için yaygın olarak kullanılan bir design pattern'dir.
  (Design Pattern = Tasarım Deseni)
- MVVM, developer'ın projeyi kodlama biçimini nasıl yapacağını açıklayan bir kültürdür.
- MVVM, 'Model-View-ViewModel' kısaltmasıdır.
- MVVM, projedeki kodları katmanlara ayırarak kodun daha okunaklı olmasını sağlar.
- MVVM, kullanıcı arayüzleri ile arka planda yapılan işlemleri ayırarak yazılım geliştirmeyi
  kolaylaştırmak, kodların düzenini ve projenin kolay devam edilebilirliğini sağlamak için
  tasarlanmış bir yazılım geliştirme mimari desenlerinden biridir.

  MVVM Katmanları:
  Model: Web servislerinden, veritabanlarından veya farklı veri kaynaklarından gelen verileri,
  kısacası uygulamada kullandığımız verileri temsil etmek için oluşturduğumuz data class'lardır.

  View: Kullanıcı arayüzünün(UI) tasarlandığı ve kullanıcı ile etkileşime girdiği yerdir.
  (Activity-Fragment)
  View katmanında lojik işlemler yapılmaz. Bu katman, kullanıcının view'larla girdiği etkileşimi
  (buton tıklamaları, text yazmaları vb.) dinleyip, bu etkileşimleri ViewModel'a ileterek
  lojik işlemlerin orda yapılmasını sağlayıp, yapılan lojik işlemler neticesinde elde edilen sonucu
  ekrandaki bir view ile kullanıcıya bildirmekten sorumludur.
  Genel olarak bu katman; sadece kullanıcının uygulama üzerindeki eylemlerini ViewModel katmanına
  bildirmekle görevlidir. İçinde mantıksal bir işlev barındırmaz.
  Örneğin; kullanıcı butona tıklayınca kullanıcının arama kutusuna girdiği değeri işlemek
  (veritabanında aratmak vb.) üzere ViewModel’e gönderir.

  ViewModel: Lojik işlemlerin yapıldığı katmandır. View'dan bu katmana istek atılır,
  bu katmanda belirli lojik işlemleri gerçekleştirilir, burada yapılan
  lojik işlemler, View katmanında observe edilir(Gözlemlenir) ve işlemlerin neticesinde elde edilen
  sonuçlar view katmanında kullanıcıya gösterilir. Yani bu katman, view'da gösterilecek olan verileri
  hazırlar.

  Yani genel olarak;
  - Bizler uygulamayı geliştirirken View içerisinde kullanıcının eylemine göre ViewModel'dan ilgili
  methodu çağırırız. ViewModel'da ya lojik bir işlem yapılır, ya servisten veri getirilir ya da
  database'den veriler getirilir. Ardından getirilen bu veriler, modellenir ve bu şekilde bir sonuç
  elde edilir. View ise bu sonucu observe eder(Gözlemler). Sonrasında da observe ettiği değeri
  kullanıcıya gösterir.

  MVVM Avantajları:
  1-) Düzenli ve bakımı kolay kod:
  MVVM, uygulamayı farklı katmanlara böldüğü için kod tabanını düzenli ve daha kolay
  bakılabilir hale getirir.

  2-) Test edilebilirlik:
  Görsel arayüzün ve kodun birbirinden ayrışması kodun test edilebilirliğini ve bakımını kolaylaştırır.

  3-) Sürdürülebilirlik - Adaptasyon:
  MVVM ile yazılan projeler, başka bir yazılımcının eline geçtiği zaman projeye adaptasyon süreci
  kısa olur ve kodları daha kolay okuyabilir.

  MVVM’i Android uygulama geliştirirken diğer desenlere göre daha fazla tercih edilme sebebi olarak;
  - View ile Model arasındaki bağlayıcı kodların daha kısa yazılabiliyor olması,
  - Projeyi daha kolay test ediliyor kılması,
  - Daha fazla modülerlik sağlaması
  gibi avantajlar sunması ve en önemlisi de Google’un destekliyor ve teşvik ediyor olması söylenebilir.



    Kavramlar:
    State: Uygulamanın çalışma zamanında mevcut olan veriler state olarak adlandırılır. Örneğin;
    Değişkenler, seçilen seçenekler, kullanıcının girdiği bilgiler vb. uygulamanın state'ini oluşturur.

    Configuration Changes (Konfigürasyon Değişiklikleri): Cihazın durumunun değiştiği halleri ifade
    eder. Örneğin, cihazın ekran döndürülmesi, dil ayarlarının değiştirilmesi veya uygulama arka
    planda çalışırken bellekten kaldırılması gibi durumlar konfigürasyon değişikliklerine örnektir.

  ViewModel:
  - ViewModel, uygulamadaki state'i önbelleğe alarak saklar. Bu sayede uygulamanın state'i
  konfigürasyon değişikleri durumlarına karşılık değerini korur ve bu değerler kaybolmaz.
  - Yani biz cihazı yatay yönde çevirdiğimizde, activity-fragment'lar sıfırdan yeniden oluşmasına
  rağmen, bunların bağlandığı viewModel'lar sıfırdan oluşmaz. Daha önceden oluşturulmuş olan
  viewModel varlığını sürdürmeye devam eder ve bu sayede ekranın yatay çevrilmesi gibi konfigurasyon
  değişikliklerinde viewModel'daki veriler sıfırlanmayacağı için activity veya fragment'ın lifecycle
  methodlarında uygulamanın state'ini manuel olarak kaydedip yönetmemize gerek kalmayacaktır.
  - Yani biz viewmodel'dan veri alarak ui'a aktardığımız bir uygulamada ekranı yan çevirdiğimizde
  herhangi bir lifecycle methodu içinde eski değişkenlerin değerini kaydetme gibi işlem yapmamıza
  gerek kalmadan ui'ın güncel ve doğru halde tekrar oluşmasını sağlarız.

  ViewModel LifeCycle:
  - ViewModel'lar, bağlandıkları activity veya fragment'lar destory edilene kadar bellekte
  varlıklarını sürdürürler. Ancak burada dikkat etmen gereken önemli bir detay var:
  Ekran yan çevrildiğinde de activity ve fragment'lar önce destory edilip sonra yeniden
  oluşturuluyorlar. Ancak viewModel, acitivity ya da fragment'ın burada tamamen yok edilmediğini,
  sadece cihazın konfigurasyonunun değiştiğini anlıyor. Bundan dolayıda bellekten silinmiyor. Ancak
  bir activity veya fragment'ın konfigurasyon değişikliğinden dolayı değil de gerçekten destoy edil-
  diği durumlarda(uygulamanın kapatılması, bir activity'nin finish() methodu ile destroy edilmesi vb.)
  viewModel bunun gerçek bir destroy olduğunu anlayıp, onCleared() methodunun çağrarak bellekten
  siliniyor.

  - Yani ViewModel'lar, Activitiy ya da fragment'ların life cycle'ından değil cihazın konfigürasyon
   değişikliklerinden bağımsızdırlar.

  - Aşağıdaki resimde de görüldüğü gibi, ekran yan çevrildiğinde viewmodel ölmez, activity gerçekten
   yıkıldığında ölür.
   https://i.stack.imgur.com/Qz5pE.png

  - onCleared(): ViewModel bellekten silinmeden önce çalışan lifecycle methodu.

  Bir ViewModel'ı başka bir Activity ile paylaşabilir miyiz?
  Bunu activitiyler ile yapamazsın. Ama fragment'lar, bulunduğu activity'nin context'ini paylaşarak
  bunu yapabilir.
